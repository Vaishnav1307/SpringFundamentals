IoC -> Inversion of control
    -> It is a principle in which spring will control logic of our application
       There are two main ways in IOC is divided
       1. DI  -> Dependency Injection -> Control is about dependencies in between the objects
       2. AoP/ Interceptors -> Aspect oriented Programming -> Intercepting and controlling methods execution
          breaking of code into different modules, also known as modularisation, where the aspect is the key unit of modularity.
          Aspects enable the implementation of crosscutting concerns such as- transaction, logging not central to business logic
          without cluttering the code core to its functionality. It does so by adding additional behaviour that is the advice to
          the existing code.

Context -> The place where you put object instances that you allow spring to be managed
           1. The spring context is like a bucket where you have all your instances stored which have unique identifiers
              and sometime aliases also

Approaches to use context ->
    1. manually defining bean with @Bean annotation
    -> When you manually defined the bean the name of the method will be taken as the name of that instance
       If you are creating two or more beans of same type then you need to specify name of instance context should
       provide you in getBean constructor, or it will give an exception
       a. We can create the beans of classes which are part of jdk
       b. We can create the beans of classes which are part of external dependencies
       - If you are creating two beans of same type then it is mandatory to specify which bean instance you want with
         @Primary or @Qualifier annotation

    2. By using stereotype annotations ( @Component and @ComponentScan )
    -> The annotation used for creating beans is @Component annotation it is a class level annotation which is given above
       the class of which bean you wanted and @ComponentScan annotation is used with it which is specified above the configuration
       class and inside @ComponentScan annotation basePackage is also specified
       a. We cannot create the beans of classes which are part of jdk
       b. We cannot create the beans of classes which are part of external dependencies


---------------------------------------------------------------------------------------------------------------------------

Controllers -> controllers are objects offering entry to the application , It is a layer which offers you entry point to
               the logic which is written in service layer

Service     -> service layer is objects implementing the use-cases which is business logic, services are define algorithm
               which happens to the data

--------------------------------------------------------------------------------------------------------------------------

Approaches to use dependency injection

1. @Autowired  -> - By placing this annotation above the declaration of object we told spring to put instance of
                    declared object which is created in context inside that attribute
                  - It injects the dependency of declared object into the class where it is declared. It is necessary that
                    bean of class which dependency you wanted to be injects should be present in context
                    [Autowired on actual fields is not recommended because it implies you attribute which is not final
                    you cannot apply final in front of @Autowired annotation ]

2. @RequiredArgsConstructor or through constructor dependency injection ->
    - we can use final keyword before the object declaration because final objects are loaded at the time of class loading
      and cannot be changed after class loading for this we can either use @RequiredArgsConstructor or manually write
      constructor which will return object














